#include <iostream>

using namespace std;
int main() {

    /**
     * 义一个指针之后，如果不进行初始化，那么它的内容是不确定的（比如0xcccc）。
     * 如果这时把它的内容当成一个地址去访问，就可能访问的是不存在的对象；
     * 更可怕的是，如果访问到的是系统核心内存区域，、
     * 修改其中内容会导致系统崩溃。这样的指针就是“无效指针”，也被叫做“野指针”
     */
     int *np = nullptr;
     np = NULL;
     np = 0;
    cout << "np = " << np << endl;
    cout << "np的地址" << &np<<endl;
    cin.get();

    // 空指针的定义方式：
    /**
     * ?	使用字面值nullptr，这是C++ 11 引入的方式，推荐使用
     * ?	使用预处理变量NULL，这是老版本的方式；
     * ?	直接使用0值；
     * 也正是因为数组名被认为是指针，所以不能直接使用数组名对另一个数组赋值，数组也不允许这样的直接拷贝：
     * 所谓的“指针运算”，就是直接对一个指针加/减一个整数值，得到的结果仍然是指针。新指针指向的数据元素，跟原指针指向的相比移动了对应个数据单位。
     */


    /***
     * 指针常量本身还是一个数据对象，它保存着另一个对象的地址，而且不能更改；而引用就是“别名”，它会被编译器直接翻译成所绑定的原始变量；所以我们会看到，引用和原始对象的地址是一样，引用并没有额外占用内存空间。这也是为什么不会有“指向引用的指针”。
引用的本质，只是C++引入的一种语法糖，它是对指针的一种伪装。
指针是C语言中最灵活、最强大的特性；引用所能做的，其实指针全都可以做。但是指针同时又令人费解、充满危险性，所以C++中通过引用来代替一些指针的用法。后面在函数部分，我们会对此有更深刻的理解

     */
     /***
      * 这里需要注意：
?	重载的函数，应该在形参的数量或者类型上有所不同；
?	形参的名称在类型中可以省略，所以只有形参名不同的函数是一样的；
?	调用函数时，编译器会根据传递的实参个数和类型，自动推断使用哪个函数；
?	主函数不能重载

      */
}
